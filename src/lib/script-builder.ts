import {
  AnalysisResult,
  PresentationScript,
  SectionScript,
  SectionTransition,
  NarrationSegment,
  TransitionType,
} from '@/types';

const DEFAULT_TRANSITION_DURATION = 1.0; // seconds

function chooseTransitionType(
  fromViz: string,
  toViz: string
): TransitionType {
  // Same visualization type → simple crossfade
  if (fromViz === toViz) return 'crossfade';

  // 3D ↔ anything → cinematic perspective push
  if (fromViz === 'threejs' || toViz === 'threejs') return 'perspective-push';

  // d3 ↔ css → parallax wipe for depth effect
  if (
    (fromViz === 'd3' && toViz === 'css') ||
    (fromViz === 'css' && toViz === 'd3')
  ) return 'parallax-wipe';

  // katex ↔ anything → zoom transition for math emphasis
  if (fromViz === 'katex' || toViz === 'katex') return 'zoom-out-in';

  // Default
  return 'slide-left';
}

function computeSegmentTimestamps(segments: NarrationSegment[]): void {
  let offset = 0;
  for (const segment of segments) {
    const pauseBefore = segment.pacing === 'pause-before' ? 0.5 : 0;
    const pauseAfter = segment.pacing === 'pause-after' ? 0.5 : 0;
    segment.startTime = offset + pauseBefore;
    segment.endTime = segment.startTime + segment.estimatedDuration;
    offset = segment.endTime + pauseAfter;
  }
}

export function buildPresentationScript(
  analysis: AnalysisResult
): PresentationScript {
  const sectionScripts: SectionScript[] = [];

  for (const section of analysis.sections) {
    if (section.script) {
      // Script was generated by Gemini — compute timestamps
      const script = { ...section.script };
      script.segments = script.segments.map((seg) => ({ ...seg }));
      computeSegmentTimestamps(script.segments);
      script.totalDuration =
        script.segments.length > 0
          ? script.segments[script.segments.length - 1].endTime
          : 0;
      sectionScripts.push(script);
    } else {
      // Fallback: create a single-segment script from the flat narration
      const stepIds =
        section.animationData?.steps?.map((s) => s.id) || ['step-1'];
      const totalSteps = stepIds.length;
      const wordsPerStep = Math.ceil(
        section.narration.split(/\s+/).length / totalSteps
      );
      const words = section.narration.split(/\s+/);

      const segments: NarrationSegment[] = stepIds.map((stepId, i) => {
        const segWords = words.slice(
          i * wordsPerStep,
          i === totalSteps - 1 ? undefined : (i + 1) * wordsPerStep
        );
        const text = segWords.join(' ');
        const estimatedDuration = Math.max(
          2,
          (segWords.length / 150) * 60
        );
        return {
          id: `seg-${section.id}-${i + 1}`,
          text,
          stepId,
          estimatedDuration,
          startTime: 0,
          endTime: 0,
          pacing: 'normal' as const,
        };
      });

      computeSegmentTimestamps(segments);

      sectionScripts.push({
        sectionId: section.id,
        fullText: section.narration,
        segments,
        totalDuration:
          segments.length > 0 ? segments[segments.length - 1].endTime : 0,
      });
    }
  }

  // Generate transitions between adjacent sections
  const transitions: SectionTransition[] = [];
  for (let i = 0; i < analysis.sections.length - 1; i++) {
    const from = analysis.sections[i];
    const to = analysis.sections[i + 1];
    transitions.push({
      fromSectionId: from.id,
      toSectionId: to.id,
      type: chooseTransitionType(from.visualization, to.visualization),
      duration: DEFAULT_TRANSITION_DURATION,
    });
  }

  // Compute total duration (sections + transitions)
  const sectionsDuration = sectionScripts.reduce(
    (sum, s) => sum + s.totalDuration,
    0
  );
  const transitionsDuration = transitions.reduce(
    (sum, t) => sum + t.duration,
    0
  );

  return {
    paperTitle: analysis.title,
    sections: sectionScripts,
    transitions,
    totalDuration: sectionsDuration + transitionsDuration,
  };
}
